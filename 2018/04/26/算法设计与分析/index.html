<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="算法," />










<meta name="description" content="#算法效率分析基础 ##1.分析框架：  算法的时间效率和空间效率都用输入规模的函数进行度量  用算法基本操作的执行次数来度量算法的时间效率，通过计算算法消耗的额外存储单元的数量来度量空间效率  区分算法的最差效率、平均效率和最优效率  本框架主要关心一点：当算法的输入规模趋向于无限大时，它的运行时间函数增长次数">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与分析">
<meta property="og:url" content="http://yoursite.com/2018/04/26/算法设计与分析/index.html">
<meta property="og:site_name" content="黄国航的博客">
<meta property="og:description" content="#算法效率分析基础 ##1.分析框架：  算法的时间效率和空间效率都用输入规模的函数进行度量  用算法基本操作的执行次数来度量算法的时间效率，通过计算算法消耗的额外存储单元的数量来度量空间效率  区分算法的最差效率、平均效率和最优效率  本框架主要关心一点：当算法的输入规模趋向于无限大时，它的运行时间函数增长次数">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%8D%95%E8%8E%B7.JPG">
<meta property="og:updated_time" content="2018-05-03T15:41:03.413Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法设计与分析">
<meta name="twitter:description" content="#算法效率分析基础 ##1.分析框架：  算法的时间效率和空间效率都用输入规模的函数进行度量  用算法基本操作的执行次数来度量算法的时间效率，通过计算算法消耗的额外存储单元的数量来度量空间效率  区分算法的最差效率、平均效率和最优效率  本框架主要关心一点：当算法的输入规模趋向于无限大时，它的运行时间函数增长次数">
<meta name="twitter:image" content="https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%8D%95%E8%8E%B7.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/26/算法设计与分析/"/>





  <title>算法设计与分析 | 黄国航的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黄国航的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/算法设计与分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄国航">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄国航的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法设计与分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T21:50:44+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/04/26/算法设计与分析/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/04/26/算法设计与分析/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#算法效率分析基础</p>
<p>##1.分析框架：</p>
<ul>
<li><p>算法的时间效率和空间效率都用输入规模的函数进行度量</p>
</li>
<li><p>用算法基本操作的执行次数来度量算法的时间效率，通过计算算法消耗的额外存储单元的数量来度量空间效率</p>
</li>
<li><p>区分算法的最差效率、平均效率和最优效率</p>
</li>
<li><p>本框架主要关心一点：当算法的输入规模趋向于无限大时，它的运行时间函数增长次数</p>
<a id="more"></a>
</li>
</ul>
<h2 id="2-渐进符号"><a href="#2-渐进符号" class="headerlink" title="2.渐进符号"></a>2.渐进符号</h2><p>存在大于0的常数c,c1,c2,和非负的整数n0，使得：</p>
<h3 id="2-1符号O"><a href="#2-1符号O" class="headerlink" title="2.1符号O"></a>2.1符号O</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(n)∈O(g(n)) =&gt; 对于所有的n&gt;n0来说，t(n)&lt;=cg(n)</span><br></pre></td></tr></table></figure>
<h3 id="2-2符号Ω"><a href="#2-2符号Ω" class="headerlink" title="2.2符号Ω"></a>2.2符号Ω</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(n)∈Ω(g(n)) =&gt; 对于所有的n&gt;n0来说，t(n)&gt;=cg(n)</span><br></pre></td></tr></table></figure>
<h3 id="2-3符号θ"><a href="#2-3符号θ" class="headerlink" title="2.3符号θ"></a>2.3符号θ</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(n)∈θ(g(n)) =&gt; 对于所有的n&gt;n0来说，c2g(n)&lt;=t(n)&lt;=c1g(n)</span><br></pre></td></tr></table></figure>
<h2 id="3-非递归算法的数学分析"><a href="#3-非递归算法的数学分析" class="headerlink" title="3.非递归算法的数学分析"></a>3.非递归算法的数学分析</h2><p>分析非递归算法效率的通用方案：</p>
<ol>
<li>决定用哪个(哪些)参数作为输入规模的度量</li>
</ol>
<ol start="2">
<li>找出算法的基本操作（作为一规律，它总是位于算法的最内层循环中）。</li>
<li>检查基本操作的执行次数是否只依赖输入规模。如果它还依赖一些其他的特性，则最差效率、平均效率以及最优效率（如果必要）需要分别研究。</li>
<li>建立一个算法基本操作执行次数的求和表达式。</li>
<li>利用求和运算的标公式和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数。</li>
</ol>
<h2 id="4-递归算法的数学分析方法"><a href="#4-递归算法的数学分析方法" class="headerlink" title="4.递归算法的数学分析方法"></a>4.递归算法的数学分析方法</h2><p>分析递归算法效率的通用方案</p>
<p>1.决定用哪个（哪些）参数作为输入规模的度量。</p>
<p>2.找出算法的基本操作。</p>
<p>3.检查一下，对于相同规模的不同输入，基本操作的执行次数是否不同。如果不同，则必须对最差效率、平均效率以及最优效率作单独研究。</p>
<p>4.对于算法基本操作的执行次数，<strong>建立一个递推关系以及相应的初始条件</strong>。</p>
<p>5.解这个递推式，或者至少确定它有解的增长次数。</p>
<h1 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h1><h2 id="1-拓扑排序"><a href="#1-拓扑排序" class="headerlink" title="1.拓扑排序"></a>1.拓扑排序</h2><blockquote>
<p>基于减（减一）治技术的一个直接实现：不断地做这样一件事情，在余下的有向图中求出一个源它是一个没有输入边的顶点，然后把它和所有从它出发的边都删除。顶点被删除的次序就是拓扑排序的一个解</p>
</blockquote>
<h2 id="2-减常因子算法"><a href="#2-减常因子算法" class="headerlink" title="2.减常因子算法"></a>2.减常因子算法</h2><p>###2.1假币问题</p>
<p>####1.用减治法(减半）</p>
<p>把n个硬币分为两堆，每堆<code>[_</code>n/2<code>_]</code>个，每次称一堆。</p>
<p>请写出递推式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    易见   W(1)=0</span><br><span class="line"></span><br><span class="line">               W(n)=W(ën/2û)+1</span><br><span class="line"></span><br><span class="line">解得 W(n)=[_log2n_]</span><br></pre></td></tr></table></figure>
<p>####2.用减治法(减n/3）</p>
<p>​      把n个硬币分为三堆，每堆ën/3û个，每次称任意二堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    易见   W(1)=0</span><br><span class="line"></span><br><span class="line">               W(n)=W([_n/3_])+a</span><br><span class="line"></span><br><span class="line">解得 W(n)=[_log3n_]</span><br></pre></td></tr></table></figure>
<p>​    结果比减半法更好。</p>
<p>###2.2俄式乘法</p>
<p> 设n、m是整数，以n为实例规模的度量。</p>
<p> 若n为偶数，则</p>
<pre><code>n·m=(n/2)· 2m
</code></pre><p> 若n为奇数，则</p>
<pre><code>n·m=((n-1)/2)· 2m+m
</code></pre><p> 以  1·m=m  为算法停止的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">  n           m                </span><br><span class="line"> 50         65 </span><br><span class="line"> 25        130</span><br><span class="line"> 12        260  +130</span><br><span class="line">  6         520</span><br><span class="line">  3       1040  </span><br><span class="line">  1       2080  +1040</span><br><span class="line">           2080  +2080                     </span><br><span class="line">                   = 3250</span><br></pre></td></tr></table></figure>
<h3 id="2-3约瑟夫问题"><a href="#2-3约瑟夫问题" class="headerlink" title="2.3约瑟夫问题"></a>2.3约瑟夫问题</h3><p>存在一个L(n,m) 递推公式：</p>
<p>令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是L[n,m]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L[1,m]=1;</span><br><span class="line"></span><br><span class="line">L[i,m]=(L[i-1,m]+m) mod i; (i&gt;1）</span><br></pre></td></tr></table></figure>
<p>则可以将最初的约瑟夫斯问题写成L(41,3)＝31。</p>
<p>###2.4折半查找</p>
<p>eg:</p>
<p>位置：0  1 2   3   4  5   6   7  8   9  10 11 12</p>
<p>值：   3,14,27,31,39,42,55,70,74,81,85,93,98</p>
<p>K=70</p>
<p>​            ↑                       ↑                       ↑</p>
<p>迭代1  l=0                     m=6                    r=12</p>
<p>迭代2                                   l=7       m=9      r=12</p>
<p>迭代3                                   l,m=7    r=8</p>
<p>结果                                 m= <code>[_</code>(7+8)/2<code>_]</code>=7</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BinarySearch(A[0..n-1], k )</span><br><span class="line"></span><br><span class="line">  // 输入：已排序大小为n的序列A，待搜索对象k</span><br><span class="line"></span><br><span class="line">  // 输出：如果搜索成功，则返回k的位置，否则返回-1</span><br><span class="line"></span><br><span class="line">  l=0,r=n-1;</span><br><span class="line"></span><br><span class="line">  While l≤r</span><br><span class="line"></span><br><span class="line">   mid= [_(l+r)/2_]</span><br><span class="line"></span><br><span class="line">    if k = A[mid] return mid</span><br><span class="line"></span><br><span class="line">      else if k &lt; A[mid] r=m-1</span><br><span class="line"></span><br><span class="line">           else l=m+1</span><br><span class="line"></span><br><span class="line">  return -1</span><br></pre></td></tr></table></figure>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h2><p>例子：</p>
<p>初始数组  A[0..n-1]=[5,3, 1, 9, 8, 2, 4, 7],       </p>
<p> 位置i   0   1    2    3   4    5    6   7</p>
<p>•       5   3    1   9    8    2    4   7       i，j上的元素和分裂点比较并移动</p>
<p>•                                                        对于i遇到比分裂点大或等于时停止</p>
<p>•                                                        对于j遇到比分裂点小或等于时停止</p>
<p>•       5    3   1    9    8   2     4   7     停止后，i&lt;j  交换A[i]和A[j]</p>
<p>•                                                                       i&gt;j  交换分裂点和A[j]</p>
<p>•                                                                       i=j  A[i]= A[j]=分裂点上的值</p>
<p>•       5    3   1    4    8   2     9   7     交换后，i加1，j减1</p>
<p>•       5    3   1    4    8    2     9  7      继续前面的比较和移动</p>
<p>•       5   3    1    4    2    8     9  7</p>
<p>•       5   3    1    4    2    8     9  7       i&gt;j  交换分裂点和A[j]</p>
<p>•       2   3    1    4   5    8     9  7       一次分区完成</p>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(A[l..r])</span><br><span class="line"></span><br><span class="line">    // 使用快速排序法对序列或者子序列排序</span><br><span class="line">    // 输入：子序列A[l..r]或者序列本身A[0..n-1]</span><br><span class="line">    // 输出：非递减序列A</span><br><span class="line">    if l &lt; r</span><br><span class="line">      s ← Partition( A[l..r] )</span><br><span class="line">      QuickSort(A[l..s-1] )</span><br><span class="line">      QuickSort(A[s+1..r] ) </span><br><span class="line">    //s是中轴元素/基准点，是数组分区位置的标志</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">算法 Partition( A[l..r])</span><br><span class="line"></span><br><span class="line">    // 输入：子数组A[l..r]</span><br><span class="line">    // 输出：分裂点/基准点pivot的位置</span><br><span class="line">    p ← A[l]　i ← l; j ← r+1</span><br><span class="line">     repeat</span><br><span class="line">        repeat　i ←i + 1　until A[i]≥ p</span><br><span class="line">        repeat    j ← j – 1 until A[j] ≤ p</span><br><span class="line">        swap( A[i],A[j] )</span><br><span class="line">     until i ≥ j　　</span><br><span class="line">     swap( A[i], A[j] )　  </span><br><span class="line">     swap( A[l], A[j] )</span><br><span class="line">    return j</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cworst(n)</span><br><span class="line"></span><br><span class="line">      =(n+1)+n+…+3</span><br><span class="line"></span><br><span class="line">      =(n+2)(n+1)/2-3</span><br><span class="line"></span><br><span class="line">      ∈Θ(n2)</span><br><span class="line"> Cbest(n)</span><br><span class="line">     =2Cbest(n/2)+n </span><br><span class="line">     ∈Θ(nlog2n)</span><br><span class="line">    </span><br><span class="line"> Cavg(n)</span><br><span class="line">    	=2nlnn</span><br><span class="line">    	=1.38nlog2n</span><br></pre></td></tr></table></figure>
<h2 id="2-大整数乘法"><a href="#2-大整数乘法" class="headerlink" title="2.大整数乘法"></a>2.大整数乘法</h2><blockquote>
<p>令N为偶数，则A和B可表示为a1a2、b1b2</p>
<p>其中a1和a2分别为A的前半部和后半部。</p>
<p>A＝a1·10^N/2+a2(123456=123·106/2+456)</p>
<p>B＝bl·10^N/2+b2</p>
<p>bl 和b2则分别为B的前半部和后半部。如果按下述方法得到积(多项式相乘)  </p>
<p>A·B=(a110^n/2+a2)(b110^n/2+b2) </p>
<p>​      =a1b110^n+(a1b2+a2b1)10^n/2+a2b2</p>
</blockquote>
<p>###改进的乘法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A·B=(a110^n/2+a2)(b110^n/2+b2)</span><br><span class="line"></span><br><span class="line">      =a1b110^n+(a1b2+a2b1)10^n/2+a2b2</span><br><span class="line"></span><br><span class="line">      =a1b110^n+[(a1+a2)(b1+b2)-a1b1-a2b2)]10^n/2+a2b2</span><br></pre></td></tr></table></figure>
<p>此时需要乘法多少次？</p>
<p>​    这种方法需要3次n/2位的乘法及一些加减法。</p>
<p>​    记C(n)为计算两个n位整数相乘所需的基本操作执行次数，则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C(n)=3C(n/2)+k·n</span><br><span class="line">C(1)=1</span><br></pre></td></tr></table></figure>
<p>其中，k为常数，KN表示加法、减法所需时间与N成正比。</p>
<p>​    解此递归方程，得</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C(n)=n^log3+2kn^log3-2kn</span><br><span class="line">             ∈O(n^log3) ≈O(n^1.58)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><blockquote>
<p>给定一个n个点的点集S，求S的凸包。</p>
<p>凸集定义：</p>
<p>​        设S是平面点集，如果S中任意两点的连线都属于该集合，则称S是凸的。</p>
<p>凸包定义：</p>
<p>​        一个点集S的凸包是指包含S的最小凸集。</p>
</blockquote>
<p><strong>基本思想</strong></p>
<p>•1 将点按x轴升序排列</p>
<p>•2 找出最左点P1和最右点Pn，一定是该集合的凸包顶点</p>
<p>•3 P1到Pn的直线将凸包分成上／下包</p>
<p>•4 采用同样的方法构造上／下包</p>
<h1 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h1><h2 id="1-高斯消去法"><a href="#1-高斯消去法" class="headerlink" title="1.高斯消去法"></a>1.高斯消去法</h2><blockquote>
<p>思路是把n个线性方程构成的n元联立方程组经过一系列初等变换为一个等价的上三角矩阵方程组，最后通过反向替换法求解</p>
</blockquote>
<h4 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GaussElimination(A[1..n], b[1..n])</span><br><span class="line">    // 输入：系数矩阵A及常数项 b</span><br><span class="line">    // 输出：方程组的增广矩阵等价的上三角矩阵</span><br><span class="line">  for i=1 to n do</span><br><span class="line">    	A[i][n+1] =b[i]</span><br><span class="line">      for i =1 to n-1 do</span><br><span class="line">  	       for j= i+1 to n do</span><br><span class="line">              for k = i to n+1 do</span><br><span class="line">               A[j][k] = A[j][k] – A[i][k]*A[j][i]/A[i][i]</span><br></pre></td></tr></table></figure>
<p>####时间复杂度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(n)∈Θ(n^3)</span><br></pre></td></tr></table></figure>
<h2 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h2><h4 id="构造堆（自底向上）"><a href="#构造堆（自底向上）" class="headerlink" title="构造堆（自底向上）"></a>构造堆（自底向上）</h4><h5 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HeapBottomUp(H[1..n])</span><br><span class="line">//输入：一个可排序元素的数组</span><br><span class="line">//输出：一个堆</span><br><span class="line">for i&lt;-[_n/2_] downto 1 do</span><br><span class="line">	k&lt;-i;v&lt;-H[k]</span><br><span class="line">	heap&lt;-false</span><br><span class="line">	while not heap and 2*k&lt;=n do</span><br><span class="line">		j&lt;-2*k</span><br><span class="line">		if j&lt;n//存在两个子女</span><br><span class="line">			if H[j]&lt;H[j+1] </span><br><span class="line">				j&lt;-j+1</span><br><span class="line">		if v&gt;=H[j]</span><br><span class="line">			heap&lt;-true</span><br><span class="line">		else H[k]&lt;-H[j];k&lt;-j;</span><br><span class="line">	H[k]&lt;-v</span><br></pre></td></tr></table></figure>
<p>Cworst(n)=2(n-log2(n+1))</p>
<p>一个规模为n的堆只需不到2n次比较就能构造完成</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>堆排序主要包括两个步骤：</p>
<p>(1)对于给定的数组构造相应的堆。</p>
<p>(2)对所构造的堆执行n-1次删除堆的根结点的操作，把删除得到的结点保存在给定数组中。</p>
</blockquote>
<p>#####例子</p>
<p>•用堆排序对数组{2，9，7，6，5，8}排序</p>
<p>•步骤1：构造堆</p>
<p>​        2,9,7,6,5,8</p>
<p>​        2,9,8,6,5,7</p>
<p>​        2,9,8,6,5,7</p>
<p>​        9,2,8,6,5,7</p>
<p>​        9,6,8,2,5,7</p>
<p>•步骤2：删除根结点</p>
<p>​            9,6,8,2,5,7</p>
<p>​            7,6,8,2,5</p>
<p>​            8,6,7,2,5</p>
<p>​            5,6,7,2</p>
<p>​            7,6,5,2</p>
<p>​            2,6,5</p>
<p>​            6,5,2</p>
<p>​            5,2</p>
<p>​            2</p>
<p>#####时间效率分析</p>
<p>1.构造堆的效率是多少？</p>
<p>O(n)</p>
<p>2.删除最大键及后续的效率</p>
<p>O(nlogn)</p>
<h2 id="3-霍纳法则"><a href="#3-霍纳法则" class="headerlink" title="3.霍纳法则"></a>3.霍纳法则</h2><blockquote>
<p>霍纳法则是由下式推导的，它不断把x作为公因子从降次以后的剩余多项式中提取出来</p>
<p>p(x)=(…(anx+an-1)x+…)x+a0</p>
</blockquote>
<h4 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Horner(P[0..n],x)</span><br><span class="line">//输入：一个n次多项式的系数数组P[0..n]，以及一个数字x</span><br><span class="line">//输出：多项式在x点的值</span><br><span class="line">p&lt;-P[n]</span><br><span class="line">for i&lt;-n-1 downto 0 do</span><br><span class="line">	p&lt;-x*p+P[i]</span><br><span class="line">return p;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>它的加法和乘法都由同一个求和式给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M(n)=A(n)=n</span><br></pre></td></tr></table></figure>
<p>####例子</p>
<p>p(x)=2x^4-x^3+3x^2+x-5</p>
<p>​       =(((2x-1)x+3)x+1)x-5</p>
<table>
<thead>
<tr>
<th>系数</th>
<th>2</th>
<th>-1</th>
<th>3</th>
<th>1</th>
<th>-5</th>
</tr>
</thead>
<tbody>
<tr>
<td>X=3</td>
<td>2</td>
<td>2x3+(-1)=5</td>
<td>5x3+3=18</td>
<td>3x18+1=55</td>
<td>55x3+(-5)=160</td>
</tr>
</tbody>
</table>
<h2 id="4-二进制幂"><a href="#4-二进制幂" class="headerlink" title="4.二进制幂"></a>4.二进制幂</h2><p>​    计算a^n的算法，有两种方法：</p>
<p><img src="https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%8D%95%E8%8E%B7.JPG" alt=""></p>
<h4 id="从左到右伪代码"><a href="#从左到右伪代码" class="headerlink" title="从左到右伪代码"></a>从左到右伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LeftRightBinaryExponentiation(a,b(n))</span><br><span class="line">//输入：一个数字a和二进制位bi,...,b0的列表b(n)</span><br><span class="line">//输出：a^n的值</span><br><span class="line">product&lt;-a</span><br><span class="line">for i&lt;-I-1 downto 0 do</span><br><span class="line">	product&lt;-product*product</span><br><span class="line">	if bi=1 product&lt;-product*a</span><br><span class="line">return product</span><br></pre></td></tr></table></figure>
<p>时间复杂度：M（n）∈logn</p>
<h4 id="从右往左伪代码"><a href="#从右往左伪代码" class="headerlink" title="从右往左伪代码"></a>从右往左伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RightLeftBinaryExponentiation(a,b(n))</span><br><span class="line">//输入：一个数字a和二进制位bi,...,b0的列表b(n)</span><br><span class="line">//输出：a^n的值</span><br><span class="line">term&lt;-a</span><br><span class="line">if b0=1 product &lt;- a</span><br><span class="line">else product &lt;- 1</span><br><span class="line">for i&lt;- 1 to I do</span><br><span class="line">	term &lt;- term*term</span><br><span class="line">	if bi=1 product&lt;-product*term</span><br><span class="line">return product</span><br></pre></td></tr></table></figure>
<p>时间复杂度：M（n）∈logn</p>
<h1 id="时空权衡"><a href="#时空权衡" class="headerlink" title="时空权衡"></a>时空权衡</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>时间效率c(n)∈θ(n)</p>
<h2 id="Hirspool"><a href="#Hirspool" class="headerlink" title="Hirspool"></a>Hirspool</h2><p>最差时间效率O(nm)</p>
<p>平均时间效率θ(n)</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/11/Spring-AOP/" rel="next" title="Spring AOP（使用AspectJ的注解方式的aop实现）">
                <i class="fa fa-chevron-left"></i> Spring AOP（使用AspectJ的注解方式的aop实现）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/03/使用Spring-MVC创建REST-API/" rel="prev" title="使用Spring MVC创建REST API">
                使用Spring MVC创建REST API <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/touxiang.png"
                alt="黄国航" />
            
              <p class="site-author-name" itemprop="name">黄国航</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hghhhh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:huangguohang123@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-渐进符号"><span class="nav-text">2.渐进符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1符号O"><span class="nav-text">2.1符号O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2符号Ω"><span class="nav-text">2.2符号Ω</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3符号θ"><span class="nav-text">2.3符号θ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-非递归算法的数学分析"><span class="nav-text">3.非递归算法的数学分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-递归算法的数学分析方法"><span class="nav-text">4.递归算法的数学分析方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#减治法"><span class="nav-text">减治法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-拓扑排序"><span class="nav-text">1.拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-减常因子算法"><span class="nav-text">2.减常因子算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3约瑟夫问题"><span class="nav-text">2.3约瑟夫问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伪代码"><span class="nav-text">伪代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分治法"><span class="nav-text">分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-快速排序"><span class="nav-text">1.快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#伪代码-1"><span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间复杂度"><span class="nav-text">时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-大整数乘法"><span class="nav-text">2.大整数乘法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凸包问题"><span class="nav-text">凸包问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变治法"><span class="nav-text">变治法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-高斯消去法"><span class="nav-text">1.高斯消去法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伪代码-2"><span class="nav-text">伪代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-堆排序"><span class="nav-text">2.堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造堆（自底向上）"><span class="nav-text">构造堆（自底向上）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#伪代码-3"><span class="nav-text">伪代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-text">堆排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-霍纳法则"><span class="nav-text">3.霍纳法则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伪代码-4"><span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度-1"><span class="nav-text">时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-二进制幂"><span class="nav-text">4.二进制幂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从左到右伪代码"><span class="nav-text">从左到右伪代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从右往左伪代码"><span class="nav-text">从右往左伪代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时空权衡"><span class="nav-text">时空权衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hirspool"><span class="nav-text">Hirspool</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄国航</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytyqQfqe';
      var conf = '6a41e203093499026ca336cb276dfdc4';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
